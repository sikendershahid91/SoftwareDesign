Please keep all files related to a homework or an assignment within the appropriate directory. Files checked in outside of specific homework or assignment directory will not be reviewed or graded for that homework/assignment.

Check in and modify files as many times as you like. You will not be able to modify the files after the deadline.

You will work as a pair, both of you are responsible for the completed work in all assignments and homework. Reasonable effort is expected from each person.

The deadlines are strict, there will be no extensions. Don't email any code to Venkat or to the mailing list. Your last check in before the deadline will be graded. If your last check in breaks the code, both you and your pair will lose significant points.

Please feel free to ask for frequent reviews. See the reviews/readme.txt file for details on how to ask for reviews.

You can evolve the answers and solutions based on the reviews. Only the latest checkin at the time of review will be looked at. Also the final check in will be the only one graded.

Please read the academic honesty policy posted on the course mailing list.

Now to homework #1.

------------------------------------------------------------------------------
HW1: Due 11:59PM February 5

Q1. What's simple design?

A design that is easy to understand, easy to maintain, minimalistic (does not have irrelevant stuff), and in case it fails, that it fails gracefully.

Q2. Why should design be simple?

Simple design allows coders to easily understand new code, or relearn old code after a long time, therefore, takes less time trying to know what the code does, and more time to tweak it to what we want. The simple design allows lower cost of maintainance, and lower effort to improve the code as we can more easily identify errors, and take fewer changes to better the program. Simple code does not have have irrelevant stuff, as it makes the code harder to navigate, and to identify the meanings of different code parts. If a simple design fails, it will fail gracefully allowing to identify the cause behind the failure, and giving us direction on how to fix the failure.

Q3. In your experience, from what you've seen, has there been problems with design not being simple or benefits from it being simple? Give examples of situations and impact. Discuss.

In my experience, designs not being simple give a lot of problem. I worked on a natural-language-processing Python program for academic research that deals with both text files, and network I/O. My job was to fix, improve, and implement changes I see fit. However, as soon as I started, I encountered a lot of problems with the code. First, the variables in the code is usually not named very descriptively. Even though there are comments to help to navigate the code, too many comments also make the code look sluggish.  Trying to understand what the code does is a difficult job. 
Second, the network I/O part needed immediate improvements to handle errors, and decrease the time to make a large amount of requests to Internet. Problem is that there was no natural division/modularity of the network code. The text-handling code and network code appeared in the same method, same module. Identifying errors, and adding error-logging becomes a chore, and wasted a lot of time because I was not sure where the error came from. Also, when I tried to improve network part to handle parallel/asynchoronous I/O requests in an attempt to reduce running time, I had to looked through all the code, moved all the network-part to a different method myself before I could begin the conversion.
