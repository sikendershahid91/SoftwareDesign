HW3: Due 11:59PM April 8

According to the article <http://martinfowler.com/bliki/BeckDesignRules.html>, what are the rules of simple design. Why are these important? Discuss the impact of these principles. Give examples of using these principles in the class so far. Also, if you like, give from examples outside of this class, but limit to your personal experiences.

Martin Fowler discusses the four rules of simple design which are defined by Kent Beck, the developer of Extreme Programming, a software development methodology.

In the priority of most significant to taking precedence over next are the following: Passes the tests, Reveals intention, No duplication, and fewest elements.

"Passes the tests" is the most important rule. This rule's primary aim is to show the software works as intended through test driven development. An example of a test driven development is unit testing. In our assignments, unit tests are written before any actual code is considered. Using the test to drive our code helps us through decision making for what can be tested and then implemented. Examples of this rule can be seen in our assignment 3, where we wrote a Fibonacci test which documented the result of a given input. We right the test before the actual code to display an error along with what the output should have been, then we attempt to correct the error thus driving our implementation through the tests. A benefit of testing also can be seen when dealing with dependencies. In unit testing we can mock the information a dependency is to provide our testing class with what we intend on receiving. This allows us to design or use a dependency with receiving the information in the format of the mock. For an example in assignment 2, where we dealt with two dependencies. we designed the code in a way where we receive the required information from the dependency in a specific format. An example of decision influenced by unit test, Instead of a unavailable warning from a dependency, we wanted our code to return an error string when the depended weather service was unavailable. Using tests allows us to make decisions for the design at the object level through tests cases. This rule has no confliction with any other rule and with it's significant influence on software development we can say this is the most important rule to be followed.

"Reveals intention" is a rule to enforce a self-documenting code, which eases readability of code and enables understanding of the programmer's intent. An example of self-documenting code is how to define name for variables, methods, objects, and classes.  Self-documenting code removes the unnecessary commenting that is done to explain what shouldn't need to be explained. In our assignments, our unit test cases have names which explicitly says what the advertised behavior of the test is. In the Fibonacci assignment, each different version was defined by a meaningful name which denoted the implementation of the method. Variables names in our assignments show their purpose and simply have meaningful names. We use variable name "index" to traverse through an array in assignment 2, not just "i." Code that reveals their intentions will be easier to understand and expand upon. When it was time to code the GUI for assignment 1, the easy-to-remember class names accelerated the writing process. We knew what GUI elements should be associated with what class. This rule allows for programs to be read by viewers.
 
"No duplication" also known as the DRY principle. DRY defines don't repeat yourself. According to the article, elimination of duplicated code "is a powerful way to drive out good designs." Duplicating code meaning rewriting the logic you have set up again. When you want to update or fix your logic, you waste time and effort to update several locations. The logic may also vary a little bit between locations, so small unnoticeable errors may appear. In assignment 3, we write the base set of test for Fibonacci. For a new algorithm of Fibonacci, we just needed to redirect the test class to reuse the base tests. It was very comfortable to write more tests of Fibonacci. Only one portion of code needed update. The core set of tests became more solid as it was tested more and more. There is often a confusion where this rule is seen to be violated. It has to do with the rule "reveals intention." This is because often programmers would duplicated segments of code which can be placed in a method and placed in a class refactored away from the code being read allowing proper readability. It is to be noted that no matter what, like Fowler states "duplication to increase clarity is often papering over a problem, when it would be better to solve it."

"Fewest elements" rule focuses on keeping the software where only minimal vital behavior performs. The issue of not abiding by this rule creates extra complexity and decrease the extensibility within the software. To the core, only the three core rules above should be followed. In writing the memoized version of Fibonacci, we wanted to reuse the recursive code. There were several options to do that. If recursive and memoized methods were turned into object methods, polymorphism helped made the solution easy. At first, we were against this option. We wanted the functions to look "nice", not attached to any object. However, all other options were either too complicated or not guaranteed. In the end, the object method option was chosen. This option satisfied the three requirements above, and in the end, that was good enough.
