HW3: Due 11:59PM April 8

According to the article <http://martinfowler.com/bliki/BeckDesignRules.html>, what are the rules of simple design. Why are these important? Discuss the impact of these principles. Give examples of using these principles in the class so far. Also, if you like, give from examples outside of this class, but limit to your personal experiences.

Martin Fowler discusses the four rules of simple design by Kent Beck from Extreme Programming.

In the priority of most significant to taking precedence over next are the following: Passes the tests, Reveals intention, No duplication, and fewest elements.

"Passes the tests" is most important because it's primary aim is to claim the software works as intended. In class, we have followed this rule very closely. All our assignments have their tests written first before the actual code is considered. We love that the tests document the intended behaviors of the code. Using tests forces us to make decisions for the design. For example, in assignment 2, instead of an warning, we wanted our code to return an error string when the weather service is unavailable. We wrote 2 tests for this behavior. Or for assignment 3, the tests document the fact that the first 2 fibonacci are 1, 1. Whenever we modify the code, the chosen behaviors must persist. If not, the tests will fail. 

"Reveals intention" is essentially self-documenting code, which eases readability of code and enables understanding of the programmer's intent. The first thing is how to name things. In assignments, our unittest methods have names that explicitly says what the tests expect. In fibonacci assignment, each different version has its unique name denoting the method of calculating inside. Variables names in our assignments so far also show their purpose. We use variable name "index" to traverse through an array in assignment 2, not just "i." Code that reveals their intentions will be easier to understand and expand upon. When it was time to code the GUI for assignment 1, the easy-to-remember class names accelerated the writing process. We knew what GUI elements should be associated with what class.
 
"No duplication" also known as the DRY principle. DRY defines don't repeat yourself. According to the article, elimination of duplicated code "is a powerful way to drive out good designs." Duplicating code meaning rewriting the logic you have set up again. When you want to update or fix your logic, you waste time and effort to update several locations. The logic may also vary a little bit between locations, so small unnoticable errors may appear. In assignment 3, we write the base set of test for fibonacci. For a new algorithm of fibonacci, we just needed to redirect the test class to reuse the base tests. It was very comfortable to write more tests of fibonacci. Only one portion of code needed update. The core set of tests became more solid as it was tested more and more.

"Fewest elements" rule focuses on keeping the software where only minimal vital behavior performs. The issue of not abiding by this rule creates extra complexity and decrease the extensibility within the software. To the core, only the three core rules above should be followed. In writing the memoized version of fibonacci, we wanted to reuse the recursive code. There were several options to do that. If recursive and memoized methods were turned into object methods, polymorphism helped made the solution easy. At first, we were against this option. We wanted the functions to look "nice", not attached to any object. However, all other options were either too complicated or not guaranteed. In the end, the object method option was chosen. This option satisified the three requirements above, and in the end, that was good enough.
